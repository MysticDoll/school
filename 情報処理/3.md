# 関係と型
## SQL と Tutorial D
### SQL
RDBMSにおいて広く利用されているデータベース言語

- データベース定義・変更
- テーブル定義・変更
- テーブルの内容に対する問合せ・更新
- 他

そのデータモデルは関係モデルとは異なる

### Tutorial D

- 関係モデルにおけるデータ定義及び操作を形式的に記述するためのデータベース言語
- 本書での形式記述に用いる
- ここでは、厳密な記法には言及せ宇、適宜説明する

### SQL
- ISO標準として統一された実用向けのDB言語
- 宣言的で詳細な処理手続きの指定は不要

- 基本操作はCURD
  - Create, Read, Update, Delete
- データの入れ物やシステムに関する操作
  - データベース領域や表、ユーザ、アクセス許可など
  - create, show, alter, drop, grant, revoke
- 表の内容であるデータそのものに関する操作
  - insert, select, update, delete

#### SQL問合せ文の基本文法
select T1･C1, T2･C2, ... (属性名の列)  
from T1, T2, ... (表名の列)  
where 条件式 (オプション)  
order by 属性名の列 (オプション)

### 関係データベースの例
#### サプライヤ
- S(SNO, SNAME, STATUS, CITY)
* DNAMEは一意とは限らない為キーではない

#### 部品
- P(PNO, PNAME, COLOR, WIGHT, CITY)

#### 出荷
- SP(SNO,PNOD,QTY)
- FK
  - {SNO}, {PNO}
  * 特定のサプライヤが特定の部品を出荷できるのは一度までとする
 
### SQL問合せの例
#### サプライヤ番号SNOが'S2'のサプライヤが出荷した部品の部品番号PNOと数量QTYの言い乱
関係代数式 $ \pi\_{PNO,QTY}(\Sigma\_{SNO = 'S2'}(SP)) $

select SP.PNO, SP.QTY  
from SP  
where SP.SNO = 'S2'

##### 自明なテーブル名の省略
select PNO, QTY  
from SP  
where SNO = 'S2'

##### テーブル名の付け替え
select R.PNO, R.QTY  
from SP as R  
where R.SNO = 'S2'

## 関係モデルにおける型
### 関係、関係変数、属性、属性値は何らかの型を持つ
- Coddの定義では「ドメイン(定義域)」
- 本書では同一視する(型は値の種類、ドメインは集合)

### 関係モデルではどのような型でも導入可能
- 体系の一貫性を担保できる限りにおいて
- システム定義の型とユーザ定義の型がある
- 必要ならば、型固有の演算子(関数)なども導入可能
- 実際のDBMSでもプラガブルな型機構を持つものも存在

### 本省での話題
- ドメイン制約の対象である比較という処理における「ドメインチェックオーバーライド」
- データ値の原子性と第一正規形
## ドメイン制約の対象である比較
### 値の比較
同じドメインに属している場合に限られるべき(著者)

### 問題提起、異なるドメインの値を比較する例
- 顧客の中に取引のあるサプライヤが存在するか
  - 異なるドメインに属する顧客のキーCNOとサプライヤのキーSNOの比較が必要

### ドメインチェックオーバーライド(DCO)
- ドメインが異なっていても比較可能(計算可能)であること
- Coddはいくつかの関係演算子のDCO版も提案した

### 厳密な型つけ(strong typing)
- 明示的(自明な場合は暗黙的)に型変化をしてドメインの一致性を保証

## いびつな「ドメインチェック」
"重量 = 数量" -> 無効  
"重量 - 数量 = 0" -> 有効

式の表現によって結果が異なる

SNO = 'X4' -> 有効(サプライヤ番号)  
PNO = 'X4' -> 有効(部品番号)  
SNO = PNO -> 無効

PNO,SNOはそれぞれ固有の型を持つ
* 物理的には同じ型で表現されるとしても論理的には異なるユーザ型であるため区別される

## 厳密な型指定(strong typing)
### セレクタ
特定の物理表現をある型の値とみなす演算子

- 例
  - e.g. SNO = SNO('X4')

### THE\_演算子
ある型の物理的な表現を取得する演算子

- 例
  - e.g. THE\_CHAR(SNO) = THE\_CHAR(CNO) : 有効

### 暗黙型変換
型が一致しないときに何らかの既知の規則に基づいて自動的に型変換を行うこと

- SNO = 'X4' $\Rightarrow$ SNO = SNO('X4')

## データ値の原子性
### (ある値が)原子的(atomic)
- そのドメインにおける単一の値であること
- DBMSによってそれ以上分解できない値であること(Codd)

### 第1正規形(1NF, First normal form)
- 全ての属性値は原子的でなければならない

### 多値
- そのドメインにおける複数の値のグループである様な値
- 1NFであるためには多値が含まれてはならない

### 筆者の問題提起
- ある型の値の集合をドメインとするとき、属性値がある値の集合であれば,1NFとみなせる
- ある属性が関係値属性(relaltion-valued attribute, RVA)ならば関係モデルとして、より効果的

### NFNF(非第1正規形)
- 例えば RVAを許す体系
  - 入れ子型関係

## RVAと1NF
### (一般的な)関係モデルとSQL
- RVAをサポートしない
- 1NFであるためには、属性のドメインとして複合値(集合や関係、内部構造を持つ値)を扱ってはならない
  - それゆえ、属性値として集合値や関係値を持てない
- ORDBMSは(純粋な)RDBMSを拡張したもの

### (筆者の立場の)関係モデル
- RVA、およびその他の内部構造を持つ属性をサポート
- 1NFであるためには、すべての属性値がサポートされる任意のドメインの単一の値であること
  - それゆえ、どのような値でも属性値となりうる
- ORDBMSは真のRDBMS

## 型(ドメイン)
### 型
名前付きの有限集合
### 型を持つもの
- 全ての値は何らかの型を持つ
- 全ての変数、属性、結果を返す演算子、演算子の個々のパラメータは何らかの方を持つ
### ある型の値を操作する唯一の手段が演算子
- ある型に対して適用可能な演算子群が存在する
  - 全ての型に代入演算子と比較演算子
  - 型によって算術演算子や関数などの演算子も
- ユーザが演算子を独自に定義するための手段も必要

## 型
### 新しい型の定義
- 型の名前
- 型を構成する値
- 型の値の物理的な候補表現
- その型のの値及び変数に適用される演算子群
  - 結果を返す演算子には結果の型も定める

### 演算子定義の例

```
operator REFLECT(P POINT) return POINT;  
  return (POINT(-THE\_X(P), -THE\_Y(P)));
end operator
```

## スカラー型と非スカラー型
### スカラー型
- 一般にはユーザ可視のコンポーネントがない型
- 本書ではタプル型でも関係型でもない型

### 非スカラー型
- スカラー型以外の型
- 本書ではタプル型または関係型

### 基底関係変数の定義例

```
var S base relation
  {SNO SNO, SNAME NAME,
   STATUS INTEGER, CITY CHAR}
  key {SNO};
```

## 生成された型
### 生成された型
- 型ジェネレータの呼び出しによって得られた型

### 型ジェネレータ
- 型を返す演算子
- 実行時ではなくコンパイル時に呼び出される
- 本書ではrelation 及び tuple

```
var SINGLE_SUPPLIER tuple
  {STATUS INTEGER, SNO SNO,
   CITY CHAR, SNAME NAME}
```

```
SINGLE_SUPPLIER := tuple
  from (S where SNO = SNO('S1'))
```
## まとめ
通常は属性の型として関係やタプル、配列などをサポートしないという立場をとる場合が多い

- 全ての関係のすべてのタプルにおいて、すべての属性に適切な型がただ一つだけ含まれていること
- 関係rの型がTであるとき、rはT型の属性を持てない
  * 関係データベース以前のデータベースではポインタが多用されており、低水準であるため扱いにくかった。
